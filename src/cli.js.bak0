/**
 * Copyright (c) 2021
 * FILE DESCRIPTION
 */

import { exec } from 'child_process';
import fs from 'fs';
import https from 'https';
import path from 'path';

import program from 'commander';
import fetch from 'node-fetch';
import { Curl, curly } from 'node-libcurl';

import * as fileutil from './fileutil.js';
import { currentDir, toAbsoluteFilePath } from './fileutil.js';
import * as jsonutil from './jsonutil.js';
import { createLogger } from './lib/loggerlib.js';
import * as utilslib from './lib/utilslib.js';

const globalConfig = jsonutil.importFile('../config/config.json');
const log = createLogger();

const DEFAULT_FETCH_HEADERS = {
  'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36',
  "accept": "*/*",
}

// RUNTIME ----------------------------------------------------------------------------------

// yarn cli runProject --name bearseum
program.option('--name <value>', 'Project name', '');
program.parse();

runProgram();

// MAIN FUNCTIONS ----------------------------------------------------------------------------------

async function runProgram() {
  const options = program.opts();
  const cmd = program.args[0];
  switch (cmd) {
    case 'runProject':
      await runProject(options.name);
      break;
    case 'test':
      await test();
      break;
    default:
      log.error(`Unknown command: ${cmd}`);
  }
}

async function test() {
  const cmd = `curl 'https://node1.web3api.com/' \\
  -H 'authority: node1.web3api.com' \\
  -H 'sec-ch-ua: "Chromium";v="94", "Google Chrome";v="94", ";Not A Brand";v="99"' \\
  -H 'sec-ch-ua-mobile: ?0' \\
  -H 'user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36' \\
  -H 'sec-ch-ua-platform: "Windows"' \\
  -H 'content-type: application/json' \\
  -H 'accept: */*' \\
  -H 'origin: https://etherscan.io' \\
  -H 'sec-fetch-site: cross-site' \\
  -H 'sec-fetch-mode: cors' \\
  -H 'sec-fetch-dest: empty' \\
  -H 'referer: https://etherscan.io/' \\
  -H 'accept-language: en-US,en;q=0.9' \\
  --data-raw '{"jsonrpc":"2.0","id":2,"method":"eth_call","params":[{"from":"0x0000000000000000000000000000000000000000","data":"0xc87b56dd0000000000000000000000000000000000000000000000000000000000000050","to":"0x03f5CeE0d698c24A42A396EC6BDAEe014057d4c8"},"latest"]}' \\
  --compressed`;
  const cmd2 = 'curl https://www.keycdn.com';
  exec(`'curl 'https://node1.web3api.com/'`, (error, stdout, stderr) => {
    if (error) {
      console.log(`error: ${error.message}`);
      return;
    }
    if (stderr) {
      console.log(`stderr: ${stderr}`);
      return;
    }
    console.log(`stdout: ${stdout}`);
  });
}

async function runProject(name, totalRuns = Infinity, secsBetweenRuns = 60) {
  try {
    log.info(`Run project ${name}`);
    let numRuns = 0;
    while (numRuns < totalRuns) {
      numRuns++;
      await doRunProject(name);
      log.info(`Sleep for ${secsBetweenRuns} seconds before starting run #${numRuns + 1}`);
      await utilslib.sleep(secsBetweenRuns * 1000);
    }
    log.info('Done!');
  } catch (e) {
    log.error('Error:', e.message, e);
  }
}

function createDb(name, project) {
  const filePath = fileutil.toAbsoluteFilePath(`../config/projects/${name}/db.json`);
  let dbData;

  if (fs.existsSync(filePath)) {
    dbData = jsonutil.importFile(filePath);
  } else {
    dbData = {};
    dbData.assets = [];
    dbData.traits = {};
  }

  if (dbData.assets.length !== project.supply) {
    log.info('Create assets...');
    for (let i = 0; i < project.supply; i++) {
      const item = {
        id: i + 1,
        tokenURI: '',
        tokenOriginalURI: '',
        state: 0,
        // stateDesc: '0=Undefined|1=NotFound|2=HasGenericImage|3=HasRealImage|4=HasTraits',
        name: '',
        image: '',
        attributes: [],
        token: {}
      };
      dbData.assets.push(item);
    }
  }

  const db = {
    data: dbData,
    filePath,
    save: () => {
      fs.writeFileSync(filePath, JSON.stringify(dbData, null, 2));
    }
  };

  db.save();

  return db;
}

function getProject(name) {
  const projectConfig = jsonutil.importFile(`../config/projects/${name}/config.json`);
  const project = { ...projectConfig };
  project.tokenURISignatur = project.tokenURISignatur ?? globalConfig.etherscan.tokenURISignatur;

  const db = createDb(name, project);
  project.db = db;

  project.nextId = db.data.nextId ?? 1;
  project.tokenURITemplate = db.data.tokenURITemplate ?? project.tokenURITemplate;

  project.getNextAsset = (fromId = 1) => {
    let id = fromId;
    while (id <= db.data.supply && db.data.assets[id - 1].token) {
      id++;
    }
    return id > db.data.supply ? null : db.data.assets[id - 1];
  };

  project.save = () => {
    db.data.name = projectConfig.name;
    db.data.collectionUrl = projectConfig.collectionUrl;
    db.data.assetUrlTemplate = projectConfig.assetUrlTemplate;
    db.data.tokenURITemplate = projectConfig.tokenURITemplate;
    db.data.contractAddress = projectConfig.contractAddress;
    db.data.supply = projectConfig.supply;
    db.data.mintCost = projectConfig.mintCost;
    db.data.nextId = project.nextId;
    db.save();
  }

  return project;
}

async function doRunProject(name) {
  log.info('doRunProject');
  const project = getProject(name);
  await crawl(project);
}

async function crawl(project) {
  log.info('Crawl project:', project.name);
  let nextId = project.nextId ?? 1;
  while (nextId <= project.supply) {
    const asset = project.getNextAsset(nextId);
    if (!asset) {
      project.save();
      break;
    }
    await crawlAsset(project, asset);
    if (!asset.token) {
      project.save();
      break;
    }
    nextId = asset.id + 1;
    project.nextId = nextId;
    project.save();
    await sleep(globalConfig.getTokenSleepMillisecs);
  }
}

async function crawlAsset(project, asset) {
  log.info('Crawl asset ID:', asset.id);
  await setTokenURI(project, asset);
  await setTokenData(project, asset);
}

async function setTokenURI(project, asset) {
  if (asset.tokenURI !== '') {
    return;
  }
  try {
    if (project.tokenURITemplate) {
      const uri = project.tokenURITemplate.replace('{ID}', asset.id)
      asset.tokenURI = uri;
    } else {
      const uri = await getTokenURIFromEtherscan(asset.id, project.contractAddress, project.tokenURISignatur);
      asset.tokenURI = uri.normalizedURI;
      asset.tokenOriginalURI = uri.originalURI;
    }
  } catch (error) {
    log.error('Error:', error);
  }
}

async function setTokenData(project, asset) {
  if (asset.tokenURI === '') {
    return;
  }
  try {
    asset.token = await getTokenFromURI(asset.tokenURI);
  } catch (error) {
    log.error('Error:', error);
  }
}

async function getTokenURIFromEtherscan(id, contractAddress, signatur) {
  const tokenURIData = createTokenURIData(id, signatur);
  const postFields = `{"jsonrpc":"2.0","id":1,"method":"eth_call","params":[{"from":"0x0000000000000000000000000000000000000000","data":"${tokenURIData}","to":"${contractAddress}"},"latest"]}`;
  const response = await curly.post('http://node1.web3api.com/', {
    postFields,
    httpHeader: ['Accept: */*', 'Content-Type: application/json', 'authority: node1.web3api.com', 'user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36', 'origin: https://etherscan.io', 'referer: https://etherscan.io/']
  });
  let data;
  try {
    data = JSON.parse(response.data);
  } catch (error) {
    throw new Error('INVALID_JSON');
  }
  if (data.error) {
    if (data.error.message && data.error.message.includes('URI query for nonexistent token')) {
      throw new Error('NON_EXISTING_TOKEN');
    }
    throw new Error('UNKNOWN');
  }
  const result = data.result;
  if (!result || result.length < 130) {
    throw new Error('INVALID_URI');
  }
  const uri = hex2a(data.result.substring(130)).replace(/\0/g, '').trim();
  log.debug('getTokenURIFromEtherscan:', uri)

  return convertURI(uri);
}

function convertURI(uri) {
  const IPFS_URL = 'ipfs://';
  let normalizedURI = uri;
  if (uri.startsWith(IPFS_URL)) {
    normalizedURI = uri.replace(IPFS_URL, 'https://ipfs.io/ipfs/');
  }
  return { normalizedURI, originalURI: uri }
}

function createTokenURIData(id, signatur) {
  const hexId = id.toString(16);
  const suffix = hexId.padStart(64, '0');
  return `${signatur}${suffix}`;
}

async function getTokenFromURI(uri) {
  const response = await fetch(uri, {
    "headers": DEFAULT_FETCH_HEADERS,
    "method": "GET",
  });
  if (response.ok) {
    const result = await response.json();
    return result;
  }
  return {}
}

function hex2a(hexx) {
  var hex = hexx.toString(); //force conversion
  var str = '';
  for (var i = 0; i < hex.length; i += 2)
    str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
  return str;
}

function sleep(millisecs, randomizeMin = 100, randomizeMax = 100) {
  const randomizeFactor = randomizeMin - randomizeMax;
  const realMillisecs = randomizeFactor ? ((getRandomIntInclusive(randomizeMin, randomizeMax) / 100) * millisecs).toFixed(0) : millisecs;
  return new Promise((resolve) => setTimeout(resolve, realMillisecs));
}

function getRandomIntInclusive(min, max) {
  const minCeil = Math.ceil(min);
  const maxFloor = Math.floor(max);
  return Math.floor(Math.random() * (maxFloor - minCeil + 1) + minCeil);
}


async function getTokenURI12222(project, id) {
  const tokenURIData = createTokenURIData(id, globalConfig.etherscan.tokenURIPrefix);

  const curl = new Curl();

  curl.setOpt('URL', 'https://node1.web3api.com/');
  curl.setOpt('FOLLOWLOCATION', 1);
  curl.setOpt('VERBOSE', 1);
  // curl.setOpt('USE_SSL', 1);

  // const certfile = 'C:\\Users\\anhe92\\Documents\\GitHub\\scraper-base\\ssh\\cacert.pem';
  const certfile = 'C:/Users/anhe92/Documents/GitHub/scraper-base/ssh/cacert.pem';

  if (certfile) {
    curl.setOpt('CAINFO', certfile);
    // This is not a boolean field! 0 -> Disabled, 2 -> Enabled
    curl.setOpt('SSL_VERIFYHOST', 2);
    curl.setOpt('SSL_VERIFYPEER', 1);
  } else {
    curl.setOpt('SSL_VERIFYHOST', 0);
    curl.setOpt('SSL_VERIFYPEER', 0);
  }

  curl.setOpt(Curl.option.POST, true);
  curl.setOpt(Curl.option.POSTFIELDS, '{"jsonrpc":"2.0","id":1,"method":"eth_call","params":[{"from":"0x0000000000000000000000000000000000000000","data":"0xc87b56dd00000000000000000000000000000000000000000000000000000000000000ea","to":"0x09f643dd754fc4effd1d2ddcf0143b54122f5aeb"},"latest"]}');

  curl.setOpt(Curl.option.HTTPHEADER, ['accept-encoding: deflate, gzip, br, zstd', 'authority: node1.web3api.com', 'sec-ch-ua: "Chromium";v="94", "Google Chrome";v="94", ";Not A Brand";v="99"', 'sec-ch-ua-mobile: ?0', 'user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36', 'sec-ch-ua-platform: "Windows"', 'content-type: application/json', 'accept: */*', 'origin: https://etherscan.io', 'sec-fetch-site: cross-site', 'sec-fetch-mode: cors', 'sec-fetch-dest: empty', 'referer: https://etherscan.io/', 'accept-language: en-US,en;q=0.9']);

  curl.on('end', () => {
    console.log('end');
    curl.close.bind(curl);
  });
  curl.on('error', (error) => {
    console.log('error:', error);
    curl.close.bind(curl);
  });
  curl.on('data', (_curl, buffer, instance) => {
    console.log('received data');
    // console.log(buffer);
    console.log(buffer.chunks[0]);
    console.log(buffer.chunks.toString());
    console.dir(JSON.stringify(buffer.chunks[0].toJSON()));
  });
  curl.perform();

  return '';
}

async function getTokenURI123456(project, id) {
  log.info('getTokenURI');
  const tokenURIData = createTokenURIData(id, globalConfig.etherscan.tokenURIPrefix);

  const headers = {
    accept: '*/*',
    'accept-language': 'en-US,en;q=0.9',
    'content-type': 'application/json',
    'sec-ch-ua': '"Chromium";v="94", "Google Chrome";v="94", ";Not A Brand";v="99"',
    'sec-ch-ua-mobile': '?0',
    'sec-ch-ua-platform': '"Windows"',
    'sec-fetch-dest': 'empty',
    'sec-fetch-mode': 'cors',
    'sec-fetch-site': 'cross-site',
    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36',
    origin: 'https://etherscan.io',
    referrer: 'https://etherscan.io/'
  };

  const certfile = 'C:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crt';
  const options = {
    // hostname: 'node1.web3api.com',
    // port: 443,
    // path: '/v1/api?a=b',
    method: 'POST',
    key: fs.readFileSync(path.resolve(fileutil.currentDir(), '../ssh/privateKey.key'), 'utf-8'),
    cert: fs.readFileSync(path.resolve(fileutil.currentDir(), '../ssh/certificate.crt'), `utf-8`),
    cainfo: fs.readFileSync(certfile, `utf-8`),
    passphrase: '',
    authority: 'node1.web3api.com',
    referrerPolicy: 'origin-when-cross-origin',
    body: `{"jsonrpc":"2.0","id":1,"method":"eth_call","params":[{"from":"0x0000000000000000000000000000000000000000","data":${tokenURIData},"to":"${project.contractAddress}"},"latest"]}`,
    mode: 'cors',
    headers
  };

  console.log('start');
  const req = https.request('https://node1.web3api.com/', options, (res) => {
    console.log('start2');
    console.log('statusCode:', res.statusCode);
    console.log('headers:', res.headers);
    res.on('data', (d) => {
      console.log('data');
      process.stdout.write(d);
    });
  });

  req.end();
}

async function getTokenURI212121(project, id) {
  const tokenURIData = createTokenURIData(id, globalConfig.etherscan.tokenURIPrefix);

  const certfile = 'C:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crt';

  const options = {
    // when using this code in production, for high throughput you should not read
    //   from the filesystem for every call, it can be quite expensive. Instead
    //   consider storing these in memory
    // cert: fs.readFileSync(path.resolve(fileutil.currentDir(), '../ssh/id_rsa.pub'), `utf-8`),
    // key: fs.readFileSync(path.resolve(fileutil.currentDir(), '../ssh/id_rsa'), 'utf-8'),
    // passphrase: '',
    // cainfo: fs.readFileSync(certfile, `utf-8`),
    key: fs.readFileSync(path.resolve(fileutil.currentDir(), '../ssh/privateKey.key'), 'utf-8'),
    cert: fs.readFileSync(path.resolve(fileutil.currentDir(), '../ssh/certificate.crt'), `utf-8`),

    // in test, if you're working with self-signed certificates
    rejectUnauthorized: false,
    // ^ if you intend to use this in production, please implement your own
    //  `checkServerIdentity` function to check that the certificate is actually
    //  issued by the host you're connecting to.
    //
    //  eg implementation here:
    //  https://nodejs.org/api/https.html#https_https_request_url_options_callback

    keepAlive: false // switch to true if you're making a lot of calls from this client
  };

  // we're creating a new Agent that will now use the certs we have configured
  const sslConfiguredAgent = new https.Agent(options);

  const headers = {
    accept: '*/*',
    'accept-language': 'en-US,en;q=0.9',
    'content-type': 'application/json',
    'sec-ch-ua': '"Chromium";v="94", "Google Chrome";v="94", ";Not A Brand";v="99"',
    'sec-ch-ua-mobile': '?0',
    'sec-ch-ua-platform': '"Windows"',
    'sec-fetch-dest': 'empty',
    'sec-fetch-mode': 'cors',
    'sec-fetch-site': 'cross-site',
    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36',
    origin: 'https://etherscan.io',
    referrer: 'https://etherscan.io/'
  };

  const request = {
    headers,
    agent: sslConfiguredAgent,
    authority: 'node1.web3api.com',
    referrerPolicy: 'origin-when-cross-origin',
    body: `{"jsonrpc":"2.0","id":1,"method":"eth_call","params":[{"from":"0x0000000000000000000000000000000000000000","data":${tokenURIData},"to":"${project.contractAddress}"},"latest"]}`,
    method: 'POST',
    mode: 'cors'
  };
  const response = await fetch('https://node1.web3api.com/', request);

  log.info('request', request);
  log.info('response.ok', response.ok);
  log.info('response.length', response.length);
  log.info('response text', await response.text());
  log.info('response', response);
  return '';
}

async function getTokenURI1212(project, id) {
  const tokenURIData = createTokenURIData(id, globalConfig.etherscan.tokenURIPrefix);

  // const certfile = 'C:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crt';

  const certfile = 'C:/Users/anhe92/Documents/GitHub/scraper-base/ssh/cacert.pem';

  const options = {
    //  port: 443,
    // when using this code in production, for high throughput you should not read
    //   from the filesystem for every call, it can be quite expensive. Instead
    //   consider storing these in memory
    //  cert: fs.readFileSync(path.resolve(fileutil.currentDir(), '../ssh/certificate.crt'), `utf-8`),
    //  key: fs.readFileSync(path.resolve(fileutil.currentDir(), '../ssh/privatekey.key'), 'utf-8'),
    //  passphrase: '',
    // ca: fs.readFileSync(certfile),
    // key: fs.readFileSync(certfile, 'utf-8'),
    // cert: fs.readFileSync(certfile, `utf-8`),

    // in test, if you're working with self-signed certificates
    // rejectUnauthorized: false
    // ^ if you intend to use this in production, please implement your own
    //  `checkServerIdentity` function to check that the certificate is actually
    //  issued by the host you're connecting to.
    //
    //  eg implementation here:
    //  https://nodejs.org/api/https.html#https_https_request_url_options_callback

    keepAlive: true // switch to true if you're making a lot of calls from this client
    //  redirect: 'follow' // set to `manual` to extract redirect headers, `error` to reject redirect
  };

  // we're creating a new Agent that will now use the certs we have configured
  const sslConfiguredAgent = new https.Agent(options);

  const headers = {
    Host: 'node1.web3api.com',
    Accept: '*/*',
    'Content-Type': 'application/json',
    authority: 'node1.web3api.com',
    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36',
    origin: 'https://etherscan.io',
    referrer: 'https://etherscan.io/',
    // 'accept-language': 'en-US,en;q=0.9',
    // 'sec-ch-ua': '"Chromium";v="94", "Google Chrome";v="94", ";Not A Brand";v="99"',
    // 'sec-ch-ua-mobile': '?0',
    // 'sec-ch-ua-platform': '"Windows"',
    // 'sec-fetch-dest': 'empty',
    // 'sec-fetch-mode': 'cors',
    // 'sec-fetch-site': 'cross-site',
    Connection: 'Keep-Alive',
    'Keep-Alive': 'timeout=5, max=1000',
    'Cache-Control': 'no-cache'
  };

  // httpHeader: ['Accept: */*', 'Content-Type: application/json', 'authority: node1.web3api.com', 'user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36', 'origin: https://etherscan.io', 'referer: https://etherscan.io/']

  const data = {
    jsonrpc: '2.0',
    id: 2,
    method: 'eth_call',
    params: [
      {
        from: '0x0000000000000000000000000000000000000000',
        data: '0xc87b56dd0000000000000000000000000000000000000000000000000000000000000050',
        to: '0x03f5CeE0d698c24A42A396EC6BDAEe014057d4c8'
      },
      'latest'
    ]
  };
  const body2 = '{"jsonrpc":"2.0","id":2,"method":"eth_call","params":[{"from":"0x0000000000000000000000000000000000000000","data":"0xc87b56dd0000000000000000000000000000000000000000000000000000000000000050","to":"0x03f5CeE0d698c24A42A396EC6BDAEe014057d4c8"},"latest"]}';

  const body = JSON.stringify(data);
  console.log('body', body);
  const request = {
    // agent: sslConfiguredAgent,
    // agent: false,
    headers,
    // authority: 'node1.web3api.com',
    // referrerPolicy: 'origin-when-cross-origin',
    body: body2, // : '{"jsonrpc":"2.0","id":2,"method":"eth_call","params":[{"from":"0x0000000000000000000000000000000000000000","data":"0xc87b56dd0000000000000000000000000000000000000000000000000000000000000050","to":"0x03f5CeE0d698c24A42A396EC6BDAEe014057d4c8"},"latest"]}',
    method: 'POST'
    // mode: 'cors'
  };
  // const result = await curly.post('https://httpbin.org/post', {
  const response = await fetch('http://node1.web3api.com/', request);

  // log.info('request', request);
  log.info('response.ok', response.ok);
  log.info('response.length', response.length);
  log.info('response text', await response.text());
  log.info('response', response);
  return '';
}
